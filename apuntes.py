# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MnF4Ip4iTxzmUm6SYSN7CFWOAhr5U0w9
"""

import pandas as pd

df = pd.read_csv("salaries_by_college_major.csv") # leer el datafreme

df.head() # imprime las cabezeras de las columnas

df.shape #imprime numero de filas y columnas

df.columns # imprime las columnas

#Eliminar la última fila

#No queremos esta fila en nuestro marco de datos. Hay dos formas de eliminar esta fila. 
#La primera forma es eliminar manualmente la fila en el índice 50. La segunda forma es simplemente usar el método .dropna() de pandas.
#Creemos un nuevo marco de datos sin la última fila y examinemos las últimas 5 filas para asegurarnos de que eliminamos la última fila:

df.isna()

#Verifique el último par de filas en el marco de datos:

df.tail()

# Eliminar la última fila

# No queremos esta fila en nuestro marco de datos. Hay dos formas de eliminar esta fila. La primera forma es eliminar manualmente la fila en el índice 50.
# La segunda forma es simplemente usar el método .dropna() de pandas. 
# Creemos un nuevo marco de datos sin la última fila y examinemos las últimas 5 filas para asegurarnos de que eliminamos la última fila:

clean_df = df.dropna()
clean_df.tail()

# Acceso a columnas y celdas individuales en un marco de datos
# Encuentre una especialidad universitaria con los salarios iniciales más altos.

#Para acceder a una columna en particular desde un marco de datos, podemos usar la notación de corchetes, así:
clean_df['Starting Median Salary']

# Debería ver todos los valores impresos debajo de la celda solo para esta columna:

# Para encontrar el salario inicial más alto, simplemente podemos encadenar el método .max().
clean_df['Starting Median Salary'].max()

#El salario inicial más alto es de $ 74,300. Pero, ¿qué carrera universitaria gana tanto en promedio?
# Para esto, necesitamos saber el número de fila o índice para que podamos buscar el nombre de la carrera.
# Por suerte para nosotros, el método .idxmax() nos dará un índice para la fila con el valor más grande.
clean_df['Starting Median Salary'].idxmax()

#que es 43. Para ver el nombre de la carrera que corresponde a esa fila en particular,
# podemos usar la propiedad .loc (ubicación).
clean_df['Undergraduate Major'].loc[43]

# Aquí estamos seleccionando una columna ('Undergraduate Major') y una fila en el índice 43, por lo que estamos recuperando el valor de una celda en particular.
# Es posible que vea personas que usan la notación de corchetes dobles para lograr exactamente lo mismo:
clean_df['Undergraduate Major'][43]

# Si no especifica una columna en particular, puede usar la propiedad .loc para recuperar una fila completa:
clean_df.loc[43]

# ¿Qué carrera universitaria tiene el salario medio más alto? 
print(clean_df['Mid-Career Median Salary'].max())
print(f"Index for the max mid career salary: {clean_df['Mid-Career Median Salary'].idxmax()}")
clean_df['Undergraduate Major'][8]

# ¿Cuánto ganan los egresados de esta carrera?
# (La mitad de la carrera se define como tener más de 10 años de experiencia).

print("¿Qué especialidad universitaria tiene el salario inicial más bajo y cuánto ganan los graduados después de la universidad?\n")
salario = clean_df['Starting Median Salary'].min()
profesion = clean_df['Undergraduate Major'].loc[clean_df['Starting Median Salary'].idxmin()]
print(f"Es la especialidad de : {profesion} y su salario inicial es de : {salario}\n")
print("Posteriormente ganan:\n")
clean_df.loc[clean_df['Starting Median Salary'].idxmin()]
# Aquí he anidado el código que vimos en la lección anterior en la misma línea.

# También podemos usar la propiedad .loc para acceder a una fila completa.
# A continuación he accedido a la fila en el índice del salario medio de carrera más bajo:

print("¿Qué especialidad universitaria tiene el salario medio más bajo y cuánto pueden esperar ganar las personas con este título?\n")
salario = clean_df['Mid-Career Median Salary'].min()
profesion = clean_df['Undergraduate Major'].loc[clean_df['Starting Median Salary'].idxmin()]
print(f"Especialidad con el salario mas bajo es: {profesion}\nEsta puede ganar aproximadamente: {salario}\n")
print(clean_df.loc[clean_df['Mid-Career Median Salary'].idxmin()])


print(f"\nCONCLUSION: Lamentablemente, la educación es en realidad el título con el salario medio más bajo y el español es la especialidad con el salario inicial más bajo.")

# Clasificación de valores y adición de columnas: carreras con mayor potencial frente a menor riesgo Mayores de menor riesgo.
# Una especialización de bajo riesgo es un título en el que hay una pequeña diferencia entre los salarios más bajos y más altos. En otras palabras,
# si la diferencia entre los ingresos del percentil 10 y el percentil 90 de su especialidad es pequeña, entonces puede estar más seguro acerca de su salario después de graduarse.

# ¿Cómo calcularíamos la diferencia entre los ingresos del percentil 10 y 90? Bueno, Pandas nos permite hacer aritmética simple con columnas enteras, 
# así que todo lo que tenemos que hacer es tomar la diferencia entre las dos columnas:
clean_df['Mid-Career 90th Percentile Salary'] - clean_df['Mid-Career 10th Percentile Salary']

# Alternativamente, también puede usar el método .subtract().
clean_df['Mid-Career 90th Percentile Salary'].subtract(clean_df['Mid-Career 10th Percentile Salary'])

# El resultado de este cálculo será otra columna de marco de datos de Pandas. Podemos agregar esto a nuestro dataframe existente con el método .insert():

spread_col = clean_df['Mid-Career 90th Percentile Salary'] - clean_df['Mid-Career 10th Percentile Salary']
clean_df.insert(1, 'Spread', spread_col)
clean_df.head()

# El primer argumento es la posición donde se debe insertar la columna. En nuestro caso, está en la posición 1, por lo que es la segunda columna.

# Clasificación por el spread más bajo Para ver qué grados tienen la menor dispersión, podemos usar el método .sort_values().
# Y como solo nos interesa ver el nombre del título y la especialización, podemos pasar una lista de estos dos nombres de columna para ver el .head()
# de estas dos columnas exclusivamente.
low_risk = clean_df.sort_values('Spread')
low_risk[['Undergraduate Major', 'Spread']].head()

# Qué carreras tienen la mayor diferencia entre los ingresos altos y bajos después de la graduación.
clean_df.sort_values('Spread', ascending=False)[['Undergraduate Major', 'Spread']].head()

# Usando el método .sort_values(), ¿puedes encontrar los títulos con el mayor potencial?
# Encuentre los 5 grados principales con los valores más altos en el percentil 90.
carreras_mayor_potencial = clean_df.sort_values('Mid-Career 90th Percentile Salary', ascending=False)
carreras_mayor_potencial[['Undergraduate Major', 'Mid-Career 90th Percentile Salary']].head()

# Agrupación y pivoteo de datos con Pandas

# Muchas veces querrá sumar filas que pertenecen a una categoría en particular. Por ejemplo,
# ¿qué categoría de títulos tiene el salario promedio más alto? ¿Es STEM, Negocios o HASS (Humanidades, Artes y Ciencias Sociales)?

# Para responder a esta pregunta necesitamos aprender a usar el método .groupby(). Esto nos permite manipular datos de forma similar a una tabla dinámica de Microsoft Excel.

#Tenemos tres categorías en la columna 'Grupo': STEM, HASS y Business. Contemos cuantas carreras tenemos en cada categoría:

clean_df.groupby('Group').count()

# Ahora, ¿puede usar el método .mean() para encontrar el salario promedio por grupo?
pd.options.display.float_format = '{:,.2f}'.format  # Dar formato a los numeros
clean_df.groupby('Group').mean()